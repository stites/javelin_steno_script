import 'dart:convert';
import 'dart:typed_data';

import 'package:javelin_steno_script/javelin_steno_script.dart';
import 'package:javelin_steno_script/src/ast.dart';

import 'instruction.dart';
import 'instruction_list.dart';
import 'package:crclib/catalog.dart';

class ScriptByteCodeBuilder {
  ScriptByteCodeBuilder(this.module)
      : reachability = ScriptReachability(module);

  final ScriptModule module;

  final _bytesBuilder = BytesBuilder();
  final instructions = InstructionList();
  final functions = <String, FunctionStartInstruction>{};
  final strings = <String>{};
  late final List<String> sortedStrings;
  final stringTable = <String, int>{};
  var stringHashTableOffset = 0;
  final data = <AstNode, int>{};
  final ScriptReachability reachability;

  Uint8List createByteCode(int buttonCount) {
    _mark(buttonCount);

    module.prepareAutogeneratedCode(reachability);

    _createInstructionList();
    sortedStrings = reachability.strings.toList()..sort();
    _measureByteCode(buttonCount);
    _createByteCode(buttonCount);

    return _bytesBuilder.toBytes();
  }

  void _mark(int buttonCount) {
    _markFunction('init');
    _markFunction('tick');
    for (var i = 0; i < buttonCount; ++i) {
      _markFunction('onPress$i');
      _markFunction('onRelease$i');
    }
  }

  void _createInstructionList() {
    for (final function in module.functions.values) {
      if (function is! ScriptFunction) continue;
      if (!reachability.functions.contains(function.functionName)) continue;

      if (function != module.functions[function.functionName]) {
        throw Exception('Internal error - inconsistent function name');
      }
      // Set up placeholder instruction.
      final functionStart = FunctionStartInstruction(function);
      functions[function.functionName] = functionStart;
      addInstruction(functionStart);

      // Add function instructions
      function.statements.addInstructions(this);

      if (instructions.isEmpty || instructions.last is! ReturnInstruction) {
        // Add safety return.
        if (function.hasReturnValue) {
          addInstruction(PushIntValueInstruction(0));
        }
        addInstruction(ReturnInstruction());
      }
    }

    instructions.optimize();
  }

  void _measureByteCode(int buttonCount) {
    // init, tick, onPress/onRelease per button.
    final fixedFunctionCount = 2 + buttonCount * 2;

    // Starting offset is:
    // magic + 2 (string hash table) + function pointers
    final startingOffset = 4 + 2 + 2 * fixedFunctionCount;
    var offset = startingOffset;
    for (final instruction in instructions) {
      offset += instruction.layoutFirstPass(offset);
    }
    offset = startingOffset;
    for (final instruction in instructions) {
      offset += instruction.layoutFinalPass(offset);
    }
    for (final e in reachability.data.entries) {
      data[e.key] = offset;
      offset += e.value;
    }
    for (final string in sortedStrings) {
      stringTable[string] = offset;

      // Strings either start with 'S' (string) or 'D' (data).
      int marker = string.codeUnitAt(0);

      if (marker == 0x53 /* 'S' */) {
        offset += utf8.encode(string.substring(1)).length + 1;
      } else if (marker == 0x44 /* 'D' */) {
        offset += string.length - 1;
      } else {
        throw Exception('Internal error: Unhandled string marker');
      }
    }
    if ((offset & 1) != 0) {
      ++offset;
    }
    stringHashTableOffset = offset;
  }

  void _createByteCode(int buttonCount) {
    _bytesBuilder.add('JSS3'.codeUnits);

    add16BitValue(stringHashTableOffset);

    _addFunctionOffset('init');
    _addFunctionOffset('tick');

    for (var i = 0; i < buttonCount; ++i) {
      _addFunctionOffset('onPress$i');
      _addFunctionOffset('onRelease$i');
    }

    for (final instruction in instructions) {
      if (instruction.offset != _bytesBuilder.length) {
        throw Exception(
          'Internal error: byte code offset (${instruction.offset} vs ${_bytesBuilder.length}) mismatch at $instruction',
        );
      }
      instruction.addByteCode(this);
    }

    for (final e in data.entries) {
      _bytesBuilder.add(e.key.getData());
    }

    for (final string in sortedStrings) {
      if (stringTable[string] != _bytesBuilder.length) {
        throw Exception(
          'Internal error: byte code offset mismatch at string $string',
        );
      }

      // Strings either start with 'S' (string) or 'D' (data).
      final marker = string.codeUnitAt(0);
      if (marker == 0x53 /* 'S' */) {
        _bytesBuilder.add(utf8.encode(string.substring(1)));
        _bytesBuilder.addByte(0);
      } else if (marker == 0x44 /* 'D' */) {
        for (final byte in string.codeUnits.skip(1)) {
          _bytesBuilder.addByte(byte);
        }
      } else {
        throw Exception('Internal error: Unhandled string marker');
      }
    }

    if ((_bytesBuilder.length & 1) != 0) {
      _bytesBuilder.addByte(0);
    }

    writeStringHashTable();
  }

  void _markFunction(String name) {
    final function = module.functions[name] as ScriptFunction?;
    function?.mark(reachability);

    reachability.functions.add(name);
  }

  void _addFunctionOffset(String name) {
    final function = functions[name];
    if (function == null) {
      throw FormatException('Missing $name definition');
    }
    final offset = function.offset;
    add16BitValue(offset);
  }

  void addInstruction(ScriptInstruction instruction) =>
      instructions.add(instruction);

  void add16BitValue(int value) {
    _bytesBuilder.addByte(value);
    _bytesBuilder.addByte(value >> 8);
  }

  void addByte(int byte) {
    _bytesBuilder.addByte(byte);
  }

  void addOpcode(ScriptOpcode opcode) {
    _bytesBuilder.addByte(opcode.value);
  }

  void addOperatorOpcode(ScriptOperatorOpcode operatorOpcode) {
    _bytesBuilder.addByte(operatorOpcode.value);
  }

  void writeStringHashTable() {
    final strings = sortedStrings.where((element) => element.startsWith('S'));

    // Target duty cycle of 66%.
    final minimumHashMapSize = strings.length + (strings.length >> 1);
    var hashMapSize = 4;
    while (hashMapSize < minimumHashMapSize) {
      hashMapSize <<= 1;
    }

    add16BitValue(hashMapSize);

    // Build hashmap, index -> stroke index
    final hashMap = List<int>.filled(hashMapSize, 0);
    for (final string in strings) {
      final hashValue = string.substring(1).crc32Hash();
      var index = hashValue % hashMapSize;
      while (hashMap[index] != 0) {
        index = (index + 1) % hashMapSize;
      }
      hashMap[index] = stringTable[string]!;
    }

    for (final e in hashMap) {
      add16BitValue(e);
    }
  }
}

extension Crc32StringExtension on String {
  int crc32Hash() {
    final buffer = utf8.encode(this);

    return Crc32().convert(buffer).toBigInt().toInt();
  }
}
